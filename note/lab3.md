## 容错键值数据库的建立

lab3A要求建立容错键值数据库，编写发起指令的client以及处理指令的server两部分代码，要求系统实现强一致性。所谓的强一致性是指，即便系统本身由多台机器组成，与外界交互时表现的仿佛是一台机器，屏蔽掉所有底层同步的细节，仅仅展露客户所需要的功能。用户不必在意系统如何在多台机器间达成一致，只需要将他们的指令发送给系统即可。实验要求在多个客户以不同次序发送多条指令的情况下，集群中各个server内部的日志都是相同的，并且客户所有的指令都仅仅执行一次，实现幂等性。

### 实现幂等性

为了实现幂等性，需要给客户端发送的每条信息都编码，编码的方式用一个map来保存每个客户端执行过的指令。这个map应该是所有server都要维护的。

为了保证每个客户端的编号是唯一的，可以让让每个客户端一开始去server去注册自己，如果leader回复的信息正好丢失，那么用户又需要重新注册，同时server端信息又冗余了，这里可以参考TCP三次握手来解决可靠性的问题。但是测试不会这么麻烦，直接每个客户端用随机数做编号就好了。

### 同步指令操作

维护一个map,key是操作编号，value是管道。通过管道传递指令执行成功失败的消息。当对应leader的server接收到客户端的请求，将指令作为参数传给底层的raft，底层的raft调用start函数执行命令，start函数返回命令编号和执行时的term。raft再向管道塞入term。上层通过比较term确定指令是否执行。

因为只有leader会执行指令，所以这个map是leader保管，上层server通过比较term确定自己是否还是leader，如果不是了，就返回失败。同样的，由于leader会宕机，新leader上位没有这个map，所以这里需要加一个超时时间，超时就返回失败。每个server执行命令后，必须判断自己是否存在这儿map[index，chan]。避免错误。

### Client的逻辑

Client无脑给leader发请求就是了直到成功，超时了或者得知对方不是leader了，就换一个server继续发。

## 状态快照和日志压缩

随着系统的运行，底层raft保存的日志越来越多，这会带来三个问题。

- 每一次持久化数据的时间会越来越长，拖慢日志同步的时间，因为持久化需要用到锁。
- 当底层raft宕机后，通过持久化数据恢复的时间会非常漫长。
- 脱离集群很久的节点重新回到集群，需要同步的日志会非常的多。

因此，有必要定时对上层server的状态保存快照，压缩底层raft的日志，这样一来，不论是持久化数据的时间，恢复的时间，已经脱离集群很久节点的同步时间都会大大缩短。

### 快照的内容

server的快照应该是保存当前数据库的状态以便于未来恢复，同样的，保存了什么命令执行过的map也要保存。对于raft来说，在上层server快照的同时，会丢弃快照对应的指令，保存快照之后未执行的指令。所以在快照时，raft需要同步持久化数据，包括未执行的日志logs，指示快照对应的日志编号rf.lastIncludeIndex和lastIncludedTerm，同时还要保存raft当前的任期以及votedFor。有了这些参数，在上层server恢复快照时，底层raft能同步恢复到相应的状态。

### 快照的逻辑

使用一个阈值参数来控制底层raft的日志的长度。

对于server而言：

- 上层server执行万一个命令检测底层raft日志的长度。
- 如果持久化数据过长，上层server保存当前客户端请求日志和数据库的快照传递给底层的raft。
- 底层收到上层的快照，判断是否是最新的。
- 如果是最新的，进行持久化程序保存快照和自己当前的状态。
- 上层server收到来自底层raft的快照数据后，重置自身键值数据库和[客户编号，指令编号]字典

对于leader而言：

- Leader发现follower日志缺失或者日志不匹配，并且所需要的日志已经被快照时，切换AppendEntries为InstallSnapshot。
- follower接收到来自leader的快照操作时，与自身快照对比，决定是否进行日志覆盖或者删除。
- 如果决定接收leader快照，follower将同时持久化此快照数据和自身状态。
- follower发送快照信息给上层server，重置上层server的键值数据库以达成数据库一致。

如果follower需要的日志已经被leader快照了，此时leader就直接发快照过去而不是日志。一个快照包含整个键值数据库，而日志仅仅包含一些指令，如果键值数据库较大，发送快照不一定比同步日志更快吧。然而，当快照后leader就丢弃之前的日志，也无法同步日志了。所以，我觉得，实际应用中阈值应该设置的大一点，快照不能太频繁，否则频繁发送快照对带宽占用率太大了；另一方面，快照也要定时进行，防止宕机后恢复的时间太长。

### Server启动

- Server启动时就检查有无快照需要恢复，有就恢复。同样的还要监听底层raft是否更新了新的快照，如果有server也要从底层获取快照恢复数据。
- 检测日志长度，是否超过阈值，是就执行快照。

### Raft收到Server快照通知

-   判断此快照是否是最新。
- 如果是，截断日志，并将未执行日志（可能在某一个命令正在收到大部分节点的commit的时候，这时候命令很多）放到新建的切片中。
- 保存快照以及持久化相关变量

### Leader发送快照

当leader发现某个follower对应的nextIndex小于等于rf.lastIncludedIndex时，表明这个follower所需要的日志已经被leader丢弃，此时leader发送快照。在我的实现中，统一在发送心跳前判断是否需要快照，并且仅仅在这里发送快照，日志缺失或者不匹配时，并不会立即发送快照，而是修改相应的nextIndex变量。

### Follower收到快照逻辑

- 判断leader的快照是否比自己的新
- 如果接受快照的是leader，转为follwer
- 截断日志并且保留未执行日志

- 修改rf.lastIncludedIndex、rf.lastIncludedTerm、rf.lastApplied、rf.lastCommitIndex
- 持久化新快照和rf各变量状态
- 给上层server发送快照信息